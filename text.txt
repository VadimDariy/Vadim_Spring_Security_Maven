
                   APLICATION.YAML

server:
    port: 8189 # означает, что веб-приложение будет доступно по адресу: http://localhost:8189

servlet:
    context-path: /security # определяет префикс(корень) веб-пути для контекстного адреса: http://localhost:8189/security

#Протокол: http://
#Домен (Хост): example.com
#Префикс веб-пути: /app
#Путь к ресурсу: /about

spring:
  jpa:
      show-sql: true  # означает, что SQL-запросы будут отображаться в консоли для удобства отладки и анализа.
      properties:
        hibernate:
          dialect: org.hibernate.dialect.PostgreSQL9Dialect  # диалект Hibernate для работы с конкретной базой данных.
                                                               Здесь цифра "9" указывает, что диалект может работать с
                                                               от 9 - й версии PostgreSQL и всех последующих новых
                                                               версий PostgreSQL.
          temp:
              use_jdbc_metadata_defaults: false # не использовать значения по умолчанию для метаданных JDBC.
datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://localhost:5432/postgres?currentSchema=springsecurity
    username: postgres
    password: root

                   POM.XML

         В Maven, когда мы используем spring-boot-starter-parent в качестве родительского проекта, версия зависимостей,
    включенных в стартовый проект, устанавливается автоматически на основе версии Spring Boot, указанной в родительском
    проекте. Поэтому нам не требуется явно указывать версию для зависимостей, включенных в spring-boot-starter-parent.
    Таким образом, мы не увидем тег <version> для зависимостей, таких как spring-boot-starter-web в нашем pom.xml.

В вашем pom.xml у вас есть родительский проект:

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.16</version>
    <relativePath/>
</parent>

         Это указывает, что наш проект наследует настройки от spring-boot-starter-parent версии 2.7.16, в том числе
    версии зависимостей, таких как Spring Boot и Spring Framework. Поэтому наши зависимости, такие как
    spring-boot-starter-thymeleaf и spring-boot-starter-web, автоматически наследуют версии от родительского проекта, и
    поэтому не требуется явно указывать <version> для них.

                   THREAD-LOCAL переменные

         Thread-local переменные (или потоковые локальные переменные) - это механизм в языках программирования, который
    предоставляет каждому потоку свою собственную копию переменной. Это означает, что каждый поток может работать с
    переменной, как если бы у него была своя отдельная копия, не зная о существовании аналогичных переменных в других
    потоках. Thread-local переменные часто используются в многозадачных и многопоточных приложениях, где несколько
    потоков выполняются параллельно. Примеры использования включают в себя:
         - Сохранение состояния потока: Thread-local переменные позволяют потоку сохранять и использовать свои
                                        собственные значения, не мешая другим потокам. Например, это может быть полезно
                                        для сохранения контекста выполнения потока, такого как пользовательская
                                        информация или настройки.
         - Избегание конфликтов при доступе к данным: Когда несколько потоков имеют доступ к общим данным, thread-local
                                        переменные могут помочь избежать конфликтов и состязаний за ресурсы,
                                        предоставляя каждому потоку свою собственную копию данных.
         В различных языках программирования существуют разные механизмы для работы с thread-local переменными.
    Например, в Java существует класс ThreadLocal, который позволяет создавать и управлять такими переменными. В C++
    можно использовать ключевое слово thread_local, а в Python - модуль threading.local.


    SecurityContext - это интерфейс, представляющий контейнер для информации о безопасности в Spring Security.

    SecurityContextHolder - это класс с методами для доступа к текущему контексту безопасности в рамках выполнения
                            приложения.

    authenticated - это объект представляющий собою информацию о том, что пользователь был аутентифицирован (прошел
                    процесс аутентификации) и имеет доступ к защищенным ресурсам приложения. Этот объект может содержать
                    дополнительные сведения о пользователе, такие как его роли (Granted Authorities) и другие атрибуты
                    безопасности.

    Principal - это объект представляющий аутентифицированного пользователя. Он предоставляет информацию о текущем
                пользователе, который выполнил вход в систему. Объект Principal содержит идентификационные данные
                пользователя, такие как имя пользователя, и может быть использован для получения дополнительной
                информации о пользователе, такой как роли (Granted Authorities) и другие атрибуты безопасности.

    credentials - этот объект относится к учетным данным, таким как пароль, предоставленным пользователем в процессе
                  аутентификации. Объект Authentication в Spring Security обычно содержит идентификационные данные
                  (username) и учетные данные (credentials). Учетные данные обычно являются конфиденциальной информацией,
                  такой как пароль, используемый для проверки подлинности пользователя.

    Authorities - это объект представляет собою роли или разрешения, которые присвоены пользователю после успешной
                  аутентификации. Роли и разрешения используются для управления доступом к различным частям приложения.
                  Объект Authentication в Spring Security содержит коллекцию "authorities", представляющую роли или
                  разрешения пользователя. Роли и разрешения могут быть использованы для определения, к каким ресурсам
                  или функциональности пользователь имеет доступ.

                   КЛЮЧЕВОЕ ОТЛИЧИЕ МЕЖДУ Authorities, credentials и Principal

    Principal: Информация о текущем аутентифицированном пользователе (обычно объект, представляющий пользователя).

    Credentials: Секретные учетные данные пользователя, такие как пароль.

    Authorities: Роли или разрешения, предоставленные пользователю после успешной аутентификации.

                   РОЛИ и РАЗРЕШЕНИЯ

    Роли: Обобщенные наборы разрешений, которые присваиваются пользователю. Например, "ADMIN", "USER".

    Разрешения: Конкретные права или доступ, предоставляемые пользователю. Например, "READ", "WRITE". Разрешения могут
                быть частью ролей. Разрешения могут работать независимо от ролей.

    ИТОГО: Разрешения представляют собой конкретные права или доступ, а роли объединяют разрешения в обобщенные группы.
           Роли упрощают управление доступом, предоставляя абстракцию над наборами разрешений.

                   SERVLET DISPATCHER

         Представим многоэтажный дом как веб-приложение, а Диспетчер-Сервлета (Servlet Dispatcher) — как центральную
    часть этого веб-приложения, которая управляет запросами и перенаправляет их нужным частям приложения. В этом
    примере:

         Дом (веб-приложение): Многоэтажный дом представляет веб-приложение в целом. Это может быть, например,
                               интернет-магазин, блог или любой другой веб-ресурс.
         Этажи (разделы приложения): Каждый этаж в доме представляет разные разделы или компоненты вашего веб-приложения,
                               например, страницы для отображения продуктов, блога, контактной информации и т.д.
         Квартиры (сервлеты): Каждая квартира на этаже — это отдельный сервлет. Сервлеты обрабатывают запросы и
                              генерируют ответы для конкретных частей вашего приложения.
         Диспетчер-Сервлета (центр управления): это центральная точка управления, которая принимает все входящие запросы
                              (жильцов) и решает, какому этажу (разделу) или квартире (сервлету) направить запрос. Он
                              является координатором работы всего приложения.

         Когда клиент приходит с вопросом в Гиппермаркет, то Администратор решает, на какой этаж и в какой бутик
    отправить этого клиента.
         Например, запрос на "/products" может быть направлен на этаж (раздел) с продуктами, где соответствующий Бутик
    (сервлет) обработает запрос и сгенерирует страницу с продуктами.

    где, Гиппермаркет  - это Веб-Приложение;
         Администратор - это Диспетчер;
         Этаж          - это Разделы Приложения;
         Бутики        - это Сервлеты

















